# Unoptimized solutions for the Python Problems section of CCPS 721 Artificial Intelligence I.
# Solutions generated by Claude Opus 4.5, from problem descriptions.

# 108: Painted into a Corner

def cut_corners(points):
    n = len(points)
    point_set = {p: i for i, p in enumerate(points)}
    
    # Find all corners: (x, y), (x, y+h), (x+h, y) for h > 0
    corners = []
    for i, (x, y) in enumerate(points):
        # This point is the tip of a corner
        # Look for all h > 0 such that (x, y+h) and (x+h, y) exist
        for j, (x2, y2) in enumerate(points):
            if x2 == x and y2 > y:
                h = y2 - y
                wing2 = (x + h, y)
                if wing2 in point_set:
                    k = point_set[wing2]
                    corners.append((i, j, k))
    
    if not corners:
        return 0
    
    # For each point, track which corners it belongs to
    point_to_corners = {}
    for ci, (i, j, k) in enumerate(corners):
        for p in (i, j, k):
            if p not in point_to_corners:
                point_to_corners[p] = set()
            point_to_corners[p].add(ci)
    
    removed = set()
    best = [n]  # worst case
    
    def solve(depth):
        # Find first corner with all three points intact
        active_corner = None
        for ci, (i, j, k) in enumerate(corners):
            if i not in removed and j not in removed and k not in removed:
                active_corner = ci
                break
        
        if active_corner is None:
            if depth < best[0]:
                best[0] = depth
            return
        
        if depth >= best[0] - 1:
            return
        
        i, j, k = corners[active_corner]
        
        # Try removing each of the three points
        for p in (i, j, k):
            removed.add(p)
            solve(depth + 1)
            removed.remove(p)
    
    solve(0)
    return best[0]


# 110: Reverse the Rule 110

def reverse_110(current):
    n = len(current)
    
    # Rule 110 lookup table: maps (left, center, right) to next state
    rule_110 = {
        (0, 0, 0): 0,
        (0, 0, 1): 1,
        (0, 1, 0): 1,
        (0, 1, 1): 1,
        (1, 0, 0): 0,
        (1, 0, 1): 1,
        (1, 1, 0): 1,
        (1, 1, 1): 0
    }
    
    def apply_rule_110(prev):
        """Apply Rule 110 to get next state"""
        next_state = []
        for i in range(n):
            left = prev[(i - 1) % n]
            center = prev[i]
            right = prev[(i + 1) % n]
            next_state.append(rule_110[(left, center, right)])
        return next_state
    
    def backtrack(prev, pos):
        """Build previous state position by position"""
        # Base case: filled all positions
        if pos == n:
            # Check if applying Rule 110 gives us current state
            if apply_rule_110(prev) == current:
                return prev[:]
            else:
                return None
        
        # Try both 0 and 1 for this position
        for value in [0, 1]:
            prev.append(value)
            
            # Check if this is still valid so far
            # We can check positions that have enough neighbors filled in
            if pos >= 2:
                # Check position pos-1
                check_pos = pos - 1
                left = prev[(check_pos - 1) % n]
                center = prev[check_pos]
                right = prev[(check_pos + 1) % n] if check_pos + 1 < pos else None
                
                if right is not None:
                    expected = rule_110[(left, center, right)]
                    if expected != current[check_pos]:
                        prev.pop()
                        continue
            
            result = backtrack(prev, pos + 1)
            if result is not None:
                return result
            
            prev.pop()
        
        return None
    
    return backtrack([], 0)


# 111: Aye, eye, I

def wordomino(state, words):
    word_set = set(w for w in words if len(w) == 4)
    
    def get_trigrams(s):
        trigrams = set()
        for i in range(len(s) - 2):
            trigrams.add(s[i:i+3])
        return trigrams
    
    def solve(state, used_trigrams):
        for c in 'abcdefghijklmnopqrstuvwxyz':
            new_state = state + c
            
            if len(new_state) < 4:
                continue
            last4 = new_state[-4:]
            if last4 not in word_set:
                continue
            
            new_trigram = new_state[-3:]
            if new_trigram in used_trigrams:
                continue
            
            # Legal move - check if opponent loses
            new_used = used_trigrams | {new_trigram}
            result = solve(new_state, new_used)
            if result is None:
                return c
        
        return None
    
    return solve(state, get_trigrams(state))


# 114: Stepping stones

def stepping_stones(n, ones):
    # Initialize board with stones
    board = {}  # (row, col) -> stone number
    for pos in ones:
        board[pos] = 1
    
    def get_neighbors(r, c):
        """Get all valid neighbors of a position"""
        neighbors = []
        for dr in [-1, 0, 1]:
            for dc in [-1, 0, 1]:
                if dr == 0 and dc == 0:
                    continue
                nr, nc = r + dr, c + dc
                if 0 <= nr < n and 0 <= nc < n:
                    neighbors.append((nr, nc))
        return neighbors
    
    def get_sum(r, c):
        """Get sum of neighboring stones"""
        total = 0
        for neighbor in get_neighbors(r, c):
            if neighbor in board:
                total += board[neighbor]
        return total
    
    def backtrack(k):
        """Try to place stone k and continue"""
        best = k - 1  # Best we've achieved so far
        
        # Try each empty position
        for r in range(n):
            for c in range(n):
                if (r, c) in board:
                    continue
                
                # Check if sum of neighbors equals k
                if get_sum(r, c) == k:
                    # Place stone k here
                    board[(r, c)] = k
                    
                    # Try to continue
                    result = backtrack(k + 1)
                    best = max(best, result)
                    
                    # Backtrack
                    del board[(r, c)]
        
        return best
    
    return backtrack(2)


# 120: Count the permosetations

def count_morse(message, letters):
    # Morse code table
    morse = {
        'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.',
        'f': '..-.', 'g': '--.', 'h': '....', 'i': '..', 'j': '.---',
        'k': '-.-', 'l': '.-..', 'm': '--', 'n': '-.', 'o': '---',
        'p': '.--.', 'q': '--.-', 'r': '.-.', 's': '...', 't': '-',
        'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', 'y': '-.--',
        'z': '--..', '0': '-----', '1': '.----', '2': '..---',
        '3': '...--', '4': '....-', '5': '.....', '6': '-....',
        '7': '--...', '8': '---..', '9': '----.'
    }
    
    # Get morse codes for available letters
    available = {ch: morse[ch] for ch in letters}
    
    # For each position in the message, try each unused letter
    # and see if its morse code matches starting at that position
    
    def solve(pos, remaining):
        if pos == len(message):
            if not remaining:
                return 1
            return 0
        
        if not remaining:
            return 0
        
        count = 0
        for ch in remaining:
            code = available[ch]
            end = pos + len(code)
            if end <= len(message) and message[pos:end] == code:
                new_remaining = remaining - {ch}
                count += solve(end, new_remaining)
        
        return count
    
    return solve(0, frozenset(letters))


# 122: Forks on the Gin Lane

def gin_rummy_deadwood(hand):
    ranks = ['ace', 'two', 'three', 'four', 'five', 'six', 'seven',
             'eight', 'nine', 'ten', 'jack', 'queen', 'king']
    rank_value = {r: i + 1 for i, r in enumerate(ranks)}
    # Deadwood points: ace=1, 2-9=face value, 10/jack/queen/king=10
    deadwood_points = {r: min(i + 1, 10) for i, r in enumerate(ranks)}
    suits = ['clubs', 'diamonds', 'hearts', 'spades']
    
    # Convert hand to (rank_index, suit) pairs
    cards = [(rank_value[r], s) for r, s in hand]
    
    # Try all possible ways to partition cards into melds and deadwood
    # A meld is either a set (3-4 same rank) or a run (3+ consecutive same suit)
    
    # Generate all possible melds from the hand
    from itertools import combinations
    
    def is_set(group):
        if len(group) < 3:
            return False
        rank = group[0][0]
        return all(c[0] == rank for c in group) and len(set(c[1] for c in group)) == len(group)
    
    def is_run(group):
        if len(group) < 3:
            return False
        suit = group[0][1]
        if not all(c[1] == suit for c in group):
            return False
        sorted_ranks = sorted(c[0] for c in group)
        for i in range(1, len(sorted_ranks)):
            if sorted_ranks[i] != sorted_ranks[i-1] + 1:
                return False
        return True
    
    def is_meld(group):
        return is_set(group) or is_run(group)
    
    # Find all possible melds
    all_melds = []
    for size in range(3, len(cards) + 1):
        for combo in combinations(range(len(cards)), size):
            group = [cards[i] for i in combo]
            if is_meld(group):
                all_melds.append(set(combo))
    
    # Now find the collection of non-overlapping melds that minimizes deadwood
    best = [sum(deadwood_points[hand[i][0]] for i in range(len(cards)))]
    
    def solve(meld_idx, used, current_deadwood):
        if current_deadwood < best[0]:
            best[0] = current_deadwood
        
        if meld_idx >= len(all_melds):
            return
        
        for m in range(meld_idx, len(all_melds)):
            meld = all_melds[m]
            if meld & used:
                continue
            meld_value = sum(deadwood_points[hand[i][0]] for i in meld)
            solve(m + 1, used | meld, current_deadwood - meld_value)
    
    total_deadwood = sum(deadwood_points[hand[i][0]] for i in range(len(cards)))
    solve(0, set(), total_deadwood)
    return best[0]


# A107: The round number round

def des_chiffres(board, goal):
    if goal in board:
        return 0
    
    n = len(board)
    best = [None]
    
    def solve(current_board, depth):
        if goal in current_board:
            if best[0] is None or depth < best[0]:
                best[0] = depth
            return
        
        if len(current_board) <= 1:
            return
        
        if best[0] is not None and depth >= best[0]:
            return
        
        for i in range(len(current_board)):
            for j in range(i + 1, len(current_board)):
                a = current_board[i]
                b = current_board[j]
                
                remaining = []
                for k in range(len(current_board)):
                    if k != i and k != j:
                        remaining.append(current_board[k])
                
                results = set()
                results.add(a + b)
                results.add(a * b)
                if a > b:
                    results.add(a - b)
                if b > a:
                    results.add(b - a)
                if b != 0 and a % b == 0:
                    results.add(a // b)
                if a != 0 and b % a == 0:
                    results.add(b // a)
                
                for r in results:
                    if r > 0:
                        new_board = remaining + [r]
                        solve(new_board, depth + 1)
    
    solve(board, 0)
    return best[0]


# A114: Bandwidth minimization

def bandwidth(edges):
    n = len(edges)
    
    def try_bandwidth(limit):
        """Try to find a numbering with given bandwidth limit"""
        numbering = [-1] * n  # numbering[node] = assigned number
        used = [False] * n     # used[number] = whether number is used
        
        def backtrack(node_idx):
            """Try to assign numbers to nodes"""
            # Base case: all nodes numbered
            if node_idx == n:
                return True
            
            # Choose next node to number (could be optimized)
            node = node_idx
            
            # Try each available number
            for num in range(n):
                if used[num]:
                    continue
                
                # Check if this number violates bandwidth constraint
                valid = True
                for neighbor in edges[node]:
                    if numbering[neighbor] != -1:
                        if abs(num - numbering[neighbor]) > limit:
                            valid = False
                            break
                
                if valid:
                    # Assign this number
                    numbering[node] = num
                    used[num] = True
                    
                    if backtrack(node_idx + 1):
                        return True
                    
                    # Backtrack
                    numbering[node] = -1
                    used[num] = False
            
            return False
        
        return backtrack(0)
    
    # Iterative deepening: try bandwidth 1, 2, 3, ...
    for bw in range(1, n):
        if try_bandwidth(bw):
            return bw
    
    return n - 1


# A78: Independent Dominating Set

def independent_dominating_set(edges):
    n = len(edges)
    
    def is_valid(selected, dominated):
        """Check if current selection is valid independent dominating set"""
        # Check independence (no two selected nodes are neighbors)
        for node in selected:
            for neighbor in edges[node]:
                if neighbor in selected:
                    return False
        
        # Check domination (all nodes are either selected or have selected neighbor)
        for node in range(n):
            if node not in selected and node not in dominated:
                return False
        
        return True
    
    def backtrack(node, selected, dominated):
        """Try to build independent dominating set"""
        # Base case: processed all nodes
        if node == n:
            if is_valid(selected, dominated):
                return len(selected)
            else:
                return float('inf')
        
        best = float('inf')
        
        # Option 1: Include this node in the set
        if all(neighbor not in selected for neighbor in edges[node]):
            new_selected = selected | {node}
            new_dominated = dominated | {node} | set(edges[node])
            result = backtrack(node + 1, new_selected, new_dominated)
            best = min(best, result)
        
        # Option 2: Don't include this node
        # (must ensure it gets dominated by a neighbor eventually)
        result = backtrack(node + 1, selected, dominated)
        best = min(best, result)
        
        return best
    
    return backtrack(0, set(), set())


# A99: The sharpest axes

def vector_add_reach(start, goal, vectors, giveup):
    if start == goal:
        return 0
    
    from collections import deque
    
    visited = {start: 0}
    queue = deque([start])
    
    while queue:
        point = queue.popleft()
        dist = visited[point]
        
        if dist >= giveup:
            return None
        
        for v in vectors:
            new_point = tuple(p + d for p, d in zip(point, v))
            
            if new_point == goal:
                return dist + 1
            
            if new_point not in visited:
                visited[new_point] = dist + 1
                queue.append(new_point)
    
    return None


# A105: Blocking pawns

def blocking_pawns(n, queens):
    def get_between_squares(q1, q2):
        """Get all squares between two queens on same row, column, or diagonal"""
        r1, c1 = q1
        r2, c2 = q2
        
        squares = []
        
        # Same row
        if r1 == r2:
            for c in range(min(c1, c2) + 1, max(c1, c2)):
                squares.append((r1, c))
        # Same column
        elif c1 == c2:
            for r in range(min(r1, r2) + 1, max(r1, r2)):
                squares.append((r, c1))
        # Same diagonal
        elif abs(r1 - r2) == abs(c1 - c2):
            dr = 1 if r2 > r1 else -1
            dc = 1 if c2 > c1 else -1
            r, c = r1 + dr, c1 + dc
            while (r, c) != q2:
                squares.append((r, c))
                r += dr
                c += dc
        
        return squares
    
    def is_blocked(q1, q2, pawns_placed):
        """Check if two queens are blocked by at least one pawn"""
        between = get_between_squares(q1, q2)
        for square in between:
            if square in pawns_placed:
                return True
        return False
    
    def find_attacking_pairs(queens_set, pawns_placed):
        """Find all pairs of queens that attack each other and aren't blocked"""
        pairs = []
        queens_list = list(queens_set)
        for i in range(len(queens_list)):
            for j in range(i + 1, len(queens_list)):
                q1, q2 = queens_list[i], queens_list[j]
                r1, c1 = q1
                r2, c2 = q2
                
                # Check if they attack each other
                if r1 == r2 or c1 == c2 or abs(r1 - r2) == abs(c1 - c2):
                    # Check if not already blocked
                    if not is_blocked(q1, q2, pawns_placed):
                        pairs.append((q1, q2))
        
        return pairs
    
    def backtrack(queens_set, pawns_placed):
        # Find attacking pairs that aren't blocked
        attacking_pairs = find_attacking_pairs(queens_set, pawns_placed)
        
        # Base case: no attacking pairs
        if not attacking_pairs:
            return len(pawns_placed)
        
        # Choose first attacking pair
        q1, q2 = attacking_pairs[0]
        between = get_between_squares(q1, q2)
        
        best = float('inf')
        
        # Try placing a pawn at each position between them
        for pawn_pos in between:
            if pawn_pos not in pawns_placed and pawn_pos not in queens_set:
                new_pawns = pawns_placed | {pawn_pos}
                result = backtrack(queens_set, new_pawns)
                best = min(best, result)
        
        return best
    
    queens_set = set(queens)
    return backtrack(queens_set, set())


# A115: Set Splitting

def set_splitting(n, subsets):
    def backtrack(black):
        # Find all unicolor subsets
        unicolor = []
        for i, subset in enumerate(subsets):
            black_count = sum(1 for e in subset if e in black)
            white_count = len(subset) - black_count
            
            # If all black or all white, it's unicolor (invalid)
            if black_count == len(subset):
                unicolor.append(i)
            elif white_count == len(subset):
                # All white - this coloring is invalid
                return False
        
        # Base case: no unicolor subsets
        if not unicolor:
            return True
        
        # Choose a unicolor subset
        subset_idx = unicolor[0]
        subset = subsets[subset_idx]
        
        # Try coloring each element in this subset white
        for element in subset:
            # Skip if already white
            if element not in black:
                continue
            
            # Color this element white
            new_black = black.copy()
            new_black.remove(element)
            
            if backtrack(new_black):
                return True
        
        return False
    
    # Start with all elements black
    black = set(range(n))
    return backtrack(black)


# A116: Domino Poppers

def domino_pop(dominoes):
    def matches(pip1, pip2):
        return pip1 == pip2 or pip1 == 0 or pip2 == 0
    
    def backtrack(stack):
        # Base case: no more dominoes to process
        if not stack:
            return 0
        
        # If only one domino left, can't eliminate it
        if len(stack) == 1:
            return 1
        
        best = len(stack)  # Worst case: keep all dominoes
        
        # Try to find matching pairs
        for i in range(len(stack) - 1):
            # Check if dominoes at positions i and i+1 match
            right_pip_i = stack[i][1]
            left_pip_i_plus_1 = stack[i + 1][0]
            
            if matches(right_pip_i, left_pip_i_plus_1):
                # Remove this pair and recurse
                new_stack = stack[:i] + stack[i+2:]
                result = backtrack(new_stack)
                best = min(best, result)
        
        return best
    
    return backtrack(list(dominoes))


# A122: Unity Partition

def unity_partition(n):
    from fractions import Fraction
    
    def backtrack(target_sum, target_frac, current_list, start):
        # Base case: we've used up both the sum and the fraction
        if target_sum == 0 and target_frac == 0:
            return current_list[:]
        
        # Dead ends
        if target_sum <= 0 or target_frac <= 0:
            return None
        
        # Try each possible next number
        for num in range(start, target_sum + 1):
            reciprocal = Fraction(1, num)
            
            # Skip if reciprocal is too large
            if reciprocal > target_frac:
                continue
            
            # Try adding this number
            current_list.append(num)
            result = backtrack(target_sum - num, target_frac - reciprocal, current_list, num + 1)
            
            if result is not None:
                return result
            
            current_list.pop()
        
        return None
    
    result = backtrack(n, Fraction(1, 1), [], 2)
    return result if result else []


# T92: Cutting sticks

def cutting_sticks(sticks):
    total = sum(sticks)
    # Find n such that n(n+1)/2 = total
    n = 0
    while n * (n + 1) // 2 < total:
        n += 1
    
    # We need to assign each piece 1..n to one of the sticks
    # Each stick gets some subset of pieces, and the sum of those pieces = stick length
    # Cost for a stick cut into k pieces is (k-1)^2
    # Minimize total cost
    
    # Backtrack from piece n down to 1, assigning each piece to a stick
    # Track remaining length in each stick
    
    remaining = list(sticks)
    num_sticks = len(sticks)
    cuts = [0] * num_sticks  # number of pieces assigned to each stick
    best = [float('inf')]
    
    def solve(k, current_cost):
        if k == 0:
            # Check all sticks are fully used
            if all(r == 0 for r in remaining):
                if current_cost < best[0]:
                    best[0] = current_cost
            return
        
        if current_cost >= best[0]:
            return
        
        for i in range(num_sticks):
            if remaining[i] >= k:
                remaining[i] -= k
                old_cuts = cuts[i]
                cuts[i] += 1
                # Cost change: (old_cuts)^2 was old cost, (cuts[i]-1)^2 = old_cuts^2 is new
                # Actually cost for stick i is (cuts[i] - 1)^2 at the end
                # Incremental: new_cost - old_cost = (cuts[i]-1)^2 - (old_cuts-1)^2
                if old_cuts == 0:
                    added_cost = 0  # (1-1)^2 = 0
                else:
                    added_cost = (old_cuts) ** 2 - (old_cuts - 1) ** 2
                
                solve(k - 1, current_cost + added_cost)
                
                cuts[i] -= 1
                remaining[i] += k
        
        return
    
    solve(n, 0)
    return best[0]


# T109: Colonel Blotto and the Spymaster

def colonel_blotto(friend, enemy, prize):
    n = len(friend)
    
    def backtrack(friend_left, enemy_left, prize_left):
        # Base case: no more battlefields
        if not enemy_left:
            return 0
        
        # Choose the next enemy battlefield to assign a unit to
        enemy_idx = 0
        enemy_strength = enemy_left[enemy_idx]
        battlefield_prize = prize_left[enemy_idx]
        
        # New lists without this battlefield
        new_enemy = enemy_left[1:]
        new_prize = prize_left[1:]
        
        best = 0
        
        # Try assigning each remaining friendly unit to this battlefield
        for i in range(len(friend_left)):
            friend_strength = friend_left[i]
            new_friend = friend_left[:i] + friend_left[i+1:]
            
            # Calculate prize for this battlefield
            current_prize = 0
            if friend_strength > enemy_strength:
                current_prize = battlefield_prize
            
            # Recurse with remaining units and battlefields
            total = current_prize + backtrack(new_friend, new_enemy, new_prize)
            best = max(best, total)
        
        return best
    
    return backtrack(friend, enemy, prize)


# T120: Fox and Hounds

def fox_and_hounds(fox, hounds):
    def is_valid(pos):
        r, c = pos
        return 0 <= r < 8 and 0 <= c < 8 and (r + c) % 2 == 1
    
    def fox_moves(fox_pos):
        r, c = fox_pos
        moves = []
        for dr, dc in [(-1, -1), (-1, 1), (1, -1), (1, 1)]:
            new_pos = (r + dr, c + dc)
            if is_valid(new_pos):
                moves.append(new_pos)
        return moves
    
    def hound_moves(hound_pos):
        r, c = hound_pos
        moves = []
        for dc in [-1, 1]:
            new_pos = (r + 1, c + dc)
            if is_valid(new_pos):
                moves.append(new_pos)
        return moves
    
    def fox_turn(fox_pos, hounds_pos):
        # Fox wins if it reaches row 0
        if fox_pos[0] == 0:
            return True
        
        # Get all possible fox moves
        possible_moves = fox_moves(fox_pos)
        
        # Remove positions occupied by hounds
        possible_moves = [m for m in possible_moves if m not in hounds_pos]
        
        # Fox loses if it has no moves
        if not possible_moves:
            return False
        
        # Fox wins if any move leads to a position where hounds can't win
        for move in possible_moves:
            if not hounds_turn(move, hounds_pos):
                return True
        
        return False
    
    def hounds_turn(fox_pos, hounds_pos):
        # Try moving each hound
        for i in range(len(hounds_pos)):
            hound = hounds_pos[i]
            possible_moves = hound_moves(hound)
            
            for move in possible_moves:
                # Check if move is not occupied by another hound or fox
                if move not in hounds_pos and move != fox_pos:
                    new_hounds = list(hounds_pos)
                    new_hounds[i] = move
                    new_hounds = tuple(sorted(new_hounds))
                    
                    # Hounds win if fox can't win from this position
                    if not fox_turn(fox_pos, new_hounds):
                        return True
        
        return False
    
    return fox_turn(fox, tuple(sorted(hounds)))


# T112: Post Correspondence Problem

def post_correspondence_problem(first, second, lo, hi):
    def backtrack(first_str, second_str):
        # If strings match and length is in range, we found a solution
        if first_str == second_str and lo <= len(first_str) <= hi:
            return True
        
        # If strings are too long, stop
        if len(first_str) > hi or len(second_str) > hi:
            return False
        
        # Try appending each possible string pair
        for i in range(len(first)):
            new_first = first_str + first[i]
            new_second = second_str + second[i]
            
            if backtrack(new_first, new_second):
                return True
        
        return False
    
    return backtrack('', '')


# T114: No dogs, no masters

def no_dogs_allowed(grid):
    rows = len(grid)
    if rows == 0:
        return 0
    cols = len(grid[0])
    
    def find_bad_words(g):
        bad = []
        for r in range(rows):
            for c in range(cols):
                if c + 2 < cols:
                    word = g[r][c] + g[r][c+1] + g[r][c+2]
                    if word in ('dog', 'god'):
                        bad.append([(r,c),(r,c+1),(r,c+2)])
                if r + 2 < rows:
                    word = g[r][c] + g[r+1][c] + g[r+2][c]
                    if word in ('dog', 'god'):
                        bad.append([(r,c),(r+1,c),(r+2,c)])
        return bad
    
    def solve(g, depth, max_depth):
        bad = find_bad_words(g)
        if not bad:
            return depth
        if depth >= max_depth:
            return float('inf')
        
        target = bad[0]
        all_positions = [(r, c) for r in range(rows) for c in range(cols)]
        
        best = float('inf')
        
        for pos1 in target:
            for pos2 in all_positions:
                if pos1 == pos2:
                    continue
                if g[pos1[0]][pos1[1]] == g[pos2[0]][pos2[1]]:
                    continue
                
                new_g = [row[:] for row in g]
                new_g[pos1[0]][pos1[1]], new_g[pos2[0]][pos2[1]] = \
                    new_g[pos2[0]][pos2[1]], new_g[pos1[0]][pos1[1]]
                
                result = solve(new_g, depth + 1, min(best, max_depth))
                if result < best:
                    best = result
        
        return best
    
    g = [list(row) for row in grid]
    
    for max_d in range(0, rows * cols + 1):
        result = solve(g, 0, max_d)
        if result != float('inf'):
            return result
    
    return 0


# T121: Life is like a box of dominoes

def domino_box(tiles):
    n = len(tiles)
    if n == 0:
        return 0
    
    # Grid is 2 rows, n columns
    # We'll fill column by column from left to right
    # State: which column we're filling, what's in the grid so far
    # grid[row][col] = pip value
    
    grid = [[None]*n for _ in range(2)]
    used = [False]*n
    best = [0]
    
    def score_placement():
        # Calculate total score from adjacent matching pairs
        total = 0
        for r in range(2):
            for c in range(n):
                # Check right neighbor
                if c + 1 < n and grid[r][c] is not None and grid[r][c+1] is not None:
                    if grid[r][c] == grid[r][c+1]:
                        total += grid[r][c]
                # Check bottom neighbor
                if r == 0 and grid[0][c] is not None and grid[1][c] is not None:
                    if grid[0][c] == grid[1][c]:
                        total += grid[0][c]
        return total
    
    def solve(col):
        # If we've filled all columns, score it
        if col >= n:
            s = score_placement()
            if s > best[0]:
                best[0] = s
            return
        
        # If this column is already filled (by horizontal dominoes from previous step)
        if grid[0][col] is not None and grid[1][col] is not None:
            solve(col + 1)
            return
        
        # Option 1: Place a vertical domino in this column
        if grid[0][col] is None and grid[1][col] is None:
            for i in range(n):
                if used[i]:
                    continue
                a, b = tiles[i]
                for top, bot in [(a, b), (b, a)]:
                    grid[0][col] = top
                    grid[1][col] = bot
                    used[i] = True
                    solve(col + 1)
                    used[i] = False
                    grid[0][col] = None
                    grid[1][col] = None
        
        # Option 2: Place two horizontal dominoes starting at this column
        if col + 1 < n and grid[0][col] is None and grid[1][col] is None and grid[0][col+1] is None and grid[1][col+1] is None:
            for i in range(n):
                if used[i]:
                    continue
                for j in range(n):
                    if j == i or used[j]:
                        continue
                    a1, b1 = tiles[i]
                    a2, b2 = tiles[j]
                    # tile i on top row, tile j on bottom row
                    for left1, right1 in [(a1, b1), (b1, a1)]:
                        for left2, right2 in [(a2, b2), (b2, a2)]:
                            grid[0][col] = left1
                            grid[0][col+1] = right1
                            grid[1][col] = left2
                            grid[1][col+1] = right2
                            used[i] = True
                            used[j] = True
                            solve(col + 1)
                            used[i] = False
                            used[j] = False
                            grid[0][col] = None
                            grid[0][col+1] = None
                            grid[1][col] = None
                            grid[1][col+1] = None
    
    solve(0)
    return best[0]


